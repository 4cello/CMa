;
;  CMa program for factorial function
;
;
;  int _fac(int n) {
;	  if( n <= 0 ) return 1;
;	  else return n * fac(n-1);
;  }
;
;
 
_fac: enter 3       ; 
      loadr -3      ; put local n on top of stack
      loadc 0       ; put constant 0 on top of stack
      leq           ; compare  n <= 0
      jumpz A       ; if it is not, then jump to A 
      loadc 1       ; otherwise put constant 1 on top of stack
      storer -3     ;     update return value to the value at top of stack (=1). 
      return 3      ;     return this instance of function
   A: loadr -3      ; put value of local variable n on top of stack
      loadr -3      ; put value of local variable n on top of stack (again) 
                    ;    - now value of n is top two values on stack
      loadc 1       ; put constant 1 on top of stack
      sub           ; subtract, putting value on top of stack ( n-1 )
      mark          ; prepare to call function
      loadc _faq    ; put address of function on top of stack
      call          ; instantiate function, this invokes the function and 
                    ;   places result back on top of stack
      mul           ; multiply the top two values on stack (one of which 
                    ;   is the return value of the prev fac call)
      storer -3     ; put value of local n on top of stack
      return 3      ; return this instance of the function
 end: halt