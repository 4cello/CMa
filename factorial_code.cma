;
;  CMa program for factorial function
;
;
;  int _fac(int n) {
;	  if( n <= 1 ) return 1;
;	  else return n * fac(n-1);
;  }
;  
;  int main(){
;     int f = _fac(3);
;     printf("%i", f );
; }
;
;===============================================
;    define the global variables and assign the values

;===============================================
;    set up the program call to main, and halt
       
       alloc 1    ; return value of call note: this is before the mark
       mark       ; create stack frame
       loadc main ; put address of main on stack
       call       ; call main function
 end:  halt       ;
       
;===============================================
;    the main function
       
 main: enter 3    ; there is 1  item for the stack (f)
       alloc 1    ; allocate variable f
       alloc 1    ; allocate space for ret value
       mark       ;
       loadc _fac ; put addr of function on stack
       call       ;
       storer 1   ; put return value in local var f;
       loadr 1    ; put it on top of stack
       print      ; print the top of stack
       return 1   ;  1 local vars


_fac:  enter 1       ; 
       loadr -1      ; put local n on top of stack
       loadc 1       ; put constant 1 on top of stack
       leq           ; compare  n <= 1
       jumpz A       ; if it is not, then jump to A 
       loadc 1       ; otherwise put constant 1 on top of stack
       storer -1     ;     update return value to the value at top of stack (=1). 
       return 3      ;     return this instance of function
   A:  loadr -1      ; put value of local variable n on top of stack
       loadr -1      ; put value of local variable n on top of stack (again) 
                     ;    - now value of n is top two values on stack
       loadc 1       ; put constant 1 on top of stack
       sub           ; subtract, putting value on top of stack ( n-1 )
       mark          ; prepare to call function
       loadc _faq    ; put address of function on top of stack
       call          ; instantiate function, this invokes the function and 
                     ;   places result back on top of stack
       mul           ; multiply the top two values on stack (one of which 
                     ;   is the return value of the prev fac call)
       storer -1     ; put value of local n on top of stack
       return 3      ; return this instance of the function